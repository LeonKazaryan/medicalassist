{
  "version": 3,
  "sources": ["../../../frontend/node_modules/kdbush/src/sort.js", "../../../frontend/node_modules/kdbush/src/range.js", "../../../frontend/node_modules/kdbush/src/within.js", "../../../frontend/node_modules/kdbush/src/index.js", "../../../frontend/node_modules/supercluster/index.js"],
  "sourcesContent": ["\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n", "\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n", "\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n", "\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n", "\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n"],
  "mappings": "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",
  "names": ["getX", "getY"]
}
